from siteFerret import  global_module
from siteFerret.global_module import libname
# from global_module import Errorg
import numpy as np

import re
import subprocess
# workingDir = global_module.runFolder_path
# savingDir = global_module.save_path

#INITIALIZATION OF C FUNCTIONS
import ctypes


Cfunc = ctypes.CDLL(libname)
pdist_C = Cfunc.pdist
pdist_C.argtypes=[ctypes.POINTER(ctypes.c_void_p),ctypes.POINTER(ctypes.c_void_p),ctypes.POINTER(ctypes.c_void_p),ctypes.c_int, ctypes.c_int,ctypes.c_int]
pdist_C.restype = None

volumeArvo_C=Cfunc.ARVOLUME_C
volumeArvo_C.argtypes=[ctypes.POINTER(ctypes.c_void_p),ctypes.POINTER(ctypes.c_void_p),ctypes.c_int]
volumeArvo_C.restype = None #error message: 0 success , -1 fail

simpleV_C=Cfunc.simpleV
simpleV_C.argtypes=[ctypes.POINTER(ctypes.c_void_p),ctypes.c_int]
simpleV_C.restype=ctypes.c_double

OC_score_C = Cfunc.MOC_score
OC_score_C.argtypes=[ctypes.POINTER(ctypes.c_void_p),ctypes.c_int,ctypes.c_int,ctypes.c_double]
OC_score_C.restype=ctypes.c_double

############
############################# VOLUME CALCULATIONS ############################


def NSvolume(coordinates,nameTriang,savePath):
    """
    input: spheres coordinates. Creates a NS coordinate input file, call NS and catch its std output with volume and area info. 
    Output: Volume and area. Optional: triangulation of the pocket (in practice a renaming of the triangulation file generated by NS). 
    The latter implies a finer grid (slower NS run).
    """
    # ref_radius = 1.4 #water reference radius for SES of pocket mold
    # confFile = global_module.runFolder_path+global_module.conf
    # print(confFile)
    # NS_input= open(confFile,'r')
    # content = NS_input.readlines()
    # change=False
    # s=0
    # #1. Make sure input file is ok
    # for line in content:
    #     match = re.match("(Probe_Radius\s*=\s*)(\d*\.?\d+)",line)
    #     if match:
    #         if (float(match.group(2))==ref_radius):
    #             #assume everything is correctly set up. I expect this function the first time is called will continue, since rp=3\AA after the clustering algorithm..
    #             break
    #         else:
    #             newline = match.group(1)+re.sub('\d*\.?\d+',str(ref_radius),match.group(2))+'\n'
    #             # print(newline)
    #             content[s] = newline
    #             change =True
    #             if(nameTriang==False):
    #                 break
    #     #Refine grid..
    #     match = re.match("(Grid_scale\s*=\s*)(\d+)",line)
    #     if(match):
    #         newline = match.group(1)+re.sub('\d+',str(grid_scale),match.group(2))+'\n'
    #         content[s] = newline
    #         break
    #     s+=1
    # NS_input.close()
    # if change:
    #     NS_input= open(confFile,'w')
    #     NS_input.writelines(content)
    #     NS_input.close()
    # print(content)
    # input()
    #2. Prepare coordinate file
    np.savetxt(global_module.runFolder_path+"NanoShaper_Pocket_input.xyzr",np.array(coordinates),delimiter="\t",fmt='%.4f')

    #3. run NS
    errline = ""
    NS_call = "./NanoShaper"
    # print("HERE",global_module.runFolder_path)
    try:
        out=str(subprocess.check_output(NS_call,shell=True,cwd=global_module.runFolder_path,stderr=subprocess.STDOUT) )
        # print(out)
    except subprocess.CalledProcessError as grepexc:
        # print(grepexc.output)
        # print("NS error in Volume comp")
        match = re.search("(\s*<<ERROR>>\s*)(.+)",str(grepexc.output))
        matchS = re.search("Segmentation fault (core dumped)\s*(.+)",str(grepexc.output))
        if(match):
            errline="<<ERROR>> "+match.group(2)
        elif(matchS):
            errline = "<<ERROR>> "+matchS.group(2)
        else:
            errline = "Unexpected error.. :"+str(grepexc.output)
        # errline=re.search("(<<ERROR>>\s*)(.*)",str(grepexc.output)).group(2)
        # print("HERE")
        # print("1"+errline)
        V=None
        A=None
        
        return V,A,errline
    # print(out)
    
    matchV = re.search("(<<INFO>> Estimated volume )(\d*\.?\d+)",out)
    matchA = re.search("(<<INFO>> Total, grid conformant, surface area is )(\d*\.?\d+)",out)
    if(matchV):
        V = float(matchV.group(2))
        A = float(matchA.group(2))
    else:
        V=None
        A=None
        errline ="<<ERROR>>"+re.search("(<<ERROR>>\s*)(.*)",out).group(2)
        # print("2"+errline)
        return V,A,errline 
    
    # if(V==None):
    #     print(out)

    if(nameTriang):
        subprocess.run(['mv',global_module.runFolder_path+"/triangulatedSurf.off",savePath+"/"+nameTriang+'.off'])

    return V,A,errline

######

def naiveV(coordinates):
    coordinates = np.array(coordinates)
    radii = coordinates[:,3]
    # v=0
    # for r in radii:
    #     v+= 4./3.*PI*r*r*r
    # return v
    radii = np.ascontiguousarray(radii,dtype = ctypes.c_double)
    pr = radii.ctypes.data_as(ctypes.POINTER(ctypes.c_void_p))
    size = radii.size
    size = ctypes.c_int(size)


    return simpleV_C(pr,size)

def trueV(coordinates):
    from time import time, strftime, localtime
    '''
    Volume calculator wrapper to invoke C written ARVO module
    INPUT: Matrix containing coordinates and radius of all probes of the cluster.
    Must be first transformed in a contiguous Ctype array.
    Every 4-blocks of memory store x,y,z, and r for a given probe sphere
    '''
    
    coordinates = np.array(coordinates) #Now is a nx4 matrix
    n = coordinates.shape[0]
    # print("\n Number of probes",n)
    start = time()
    # print(coordinates)
    #C wrappers ##
    coordinates = np.ascontiguousarray(coordinates,dtype = ctypes.c_double)
    pcoord = coordinates.ctypes.data_as(ctypes.POINTER(ctypes.c_void_p))
    n = ctypes.c_int(n)
    # print("n=",n,ctypes.sizeof(n))

    result = np.empty(2)
    result = np.ascontiguousarray(result,dtype = ctypes.c_double)
    pres = result.ctypes.data_as(ctypes.POINTER(ctypes.c_void_p))
    ##

    volumeArvo_C(pres,pcoord,n)
    # print(err)
    # if(err==-1):
    #     exit("Error occurred during volume computation") 

    volume = result[0]
    area = result[1]  #Ready if needed..

    end = time()
    Localtime_elapsed=end - start
    # print("Elapsed time = ", Localtime_elapsed)
    return volume,area
###########
####################### LIGAND HIT SCORE BASED ON VOLUME CALCULATION ########################

def OC(ligand_coordinates,pocket_coordinates,scoreTh=0.2):
    from time import time, strftime, localtime
    '''
    Overlap Criterion function. Pocket correctly identified if at least 20% of the ligand lies within

    SCORE=relative part of ligand within the pocket: estimate coverage

    TO DO: compute and load ligand volume and coordinates once, instead of repeating calculation each time..
    '''
    coordinates = np.array(ligand_coordinates) #Now is a nx4 matrix
    
    n_ligand = coordinates.shape[0]
    print("\n Number of ligand spheres",n_ligand)
    start = time()
    
    #C wrappers ##
    coordinates = np.ascontiguousarray(coordinates,dtype = ctypes.c_double)
    pcoord = coordinates.ctypes.data_as(ctypes.POINTER(ctypes.c_void_p))
    n_ligand = ctypes.c_int(n_ligand)
    # print("n=",n,ctypes.sizeof(n))

    result = np.empty(2)
    result = np.ascontiguousarray(result,dtype = ctypes.c_double)
    pres = result.ctypes.data_as(ctypes.POINTER(ctypes.c_void_p))
    ##

    volumeArvo_C(pres,pcoord,n_ligand)
    ligand_volume=result[0]
    ligand_area = result[1]
    print("Ligand(s) volume is:",ligand_volume)
    print("Ligand(s) area is:",ligand_area)
    end = time()
    Localtime_elapsed=end - start
    print("Elapsed time = ", Localtime_elapsed)

    print("COMPUTING OVERLAP")
    n_pocket = len(pocket_coordinates)
    wrapped_coordinates = np.vstack((np.array(ligand_coordinates),np.array(pocket_coordinates)))
    n_total = wrapped_coordinates.shape[0]
    
    print("Number spheres :%d = %d, ligand + %d, pocket spheres " %(n_total,n_ligand.value,n_pocket))
    coordinates = wrapped_coordinates
    coordinates = np.ascontiguousarray(coordinates,dtype = ctypes.c_double)
    pcoord = coordinates.ctypes.data_as(ctypes.POINTER(ctypes.c_void_p))
    n_total = ctypes.c_int(n_total)

    score = OC_score_C(pcoord,n_total,n_ligand,ctypes.c_double(ligand_area))#,ctypes.c_double(scoreTh),ctypes.c_int(not stopAtsuccess))
    #Convert back to pythoon types ? not needed apparently
    # score =score.value
    # ligand_volume = ligand_volume.value
    if(score<0):
        raise ValueError("Unexpected negative score")
    if(score>=scoreTh):
        success = True 
    else:
        success = False 
    
    return (success,score,ligand_volume) 


###############
################################ INTERFACE WITH NS ###################
def setup_NSInput(confFile,grid_scale = 2,grid_selfInt = 2,maxProbes_selfInt=100, gridPerfil = 90, isSkin=False, accTriang=False, pInput = False, getTriangInd=False):
    #Populate this function with other set_ups.. I could also inmagine an actual hardCoding of NS input file
    s=0
    NS_input= open(confFile,'r')
    content = NS_input.readlines()
    s=0
    for line in content:
        match = re.match("(Grid_scale\s*=\s*)(\d+)",line)
        match1 = re.match("(Grid_perfil\s*=\s*)(\d+)",line)
        match2 = re.match("(Self_Intersections_Grid_Coefficient\s*=\s*)(\d+)",line)
        match3 = re.match("(Max_Probes_Self_Intersections\s*=\s*)(\d+)",line)
        match4 = re.match("(Accurate_Triangulation\s*=\s*)([a-zA-Z]+)",line)
        match5 = re.match("(Vertex_Atom_Info\s*=\s*)([a-zA-Z]+)",line)
        match6 = re.match("(Compute_Vertex_Normals\s*=\s*)([a-zA-Z]+)",line)
        match7 = re.match("(Save_Mesh_MSMS_Format\s*=\s*)([a-zA-Z]+)",line)
        match8 = re.match("(XYZR_FileName\s*=\s*)(.+)",line)
        match9=re.match("(Surface\s*=\s*)(.+)",line)
        if(match):
            newline = match.group(1)+re.sub('\d+',str(grid_scale),match.group(2))+'\n'
            content[s] = newline
        elif(match1):
            newline = match1.group(1)+re.sub('\d+',str(gridPerfil),match1.group(2))+'\n'
            content[s] = newline
        elif(match2):
            newline = match2.group(1)+re.sub('\d+',str(grid_selfInt),match2.group(2))+'\n'
            content[s] = newline
        elif(match3):
            newline = match3.group(1)+re.sub('\d+',str(maxProbes_selfInt),match3.group(2))+'\n'
            content[s] = newline
        elif(match8):
            if(pInput):
                newline = match8.group(1)+re.sub('.+',"NanoShaper_Pocket_input.xyzr",match8.group(2))+'\n'
            else:
                newline = match8.group(1)+re.sub('.+',"NanoShaper_input.xyzr",match8.group(2))+'\n' 
            content[s] = newline
        elif(match4):
            if(accTriang):
                newline = match4.group(1)+re.sub('[a-zA-Z]+',"true",match4.group(2))+'\n'
            else:
                newline = match4.group(1)+re.sub('[a-zA-Z]+',"false",match4.group(2))+'\n'
            content[s] = newline
        elif(match5):
            if(getTriangInd):
                #Extra column in off file containing indexes of closest (exposed) atom
                newline = match5.group(1)+re.sub('[a-zA-Z]+',"true",match5.group(2))+'\n'
            else:
                newline = match5.group(1)+re.sub('[a-zA-Z]+',"false",match5.group(2))+'\n'
            content[s] = newline
        elif(match6):
            newline = match6.group(1)+re.sub('[a-zA-Z]+',"false",match6.group(2))+'\n'
            content[s] = newline
        elif(match7):
            newline = match7.group(1)+re.sub('[a-zA-Z]+',"false",match7.group(2))+'\n'
            content[s] = newline
        elif(match9):
            if(isSkin):
                newline = match9.group(1)+re.sub('.+',"skin",match9.group(2))+'\n'
            else:
                newline = match9.group(1)+re.sub('.+',"ses",match9.group(2))+'\n'
            content[s] = newline
        s+=1
    NS_input.close()
    NS_input= open(confFile,'w')
    NS_input.writelines(content)
    NS_input.close()
    return

def setUP_accurateTriang(confFile):

    setup_NSInput(confFile,grid_selfInt=2,accTriang=True)
    NS_input= open(confFile,'r')
    content = NS_input.readlines()
    s=0
    for line in content:
        # match = re.match("(Grid_scale\s*=\s*)(\d+)",line)
        # match1 = re.match("(Accurate_Triangulation\s*=\s*)([a-zA-Z]+)",line)
        match2 = re.match("(Vertex_Atom_Info\s*=\s*)([a-zA-Z]+)",line)
        match3 = re.match("(Compute_Vertex_Normals\s*=\s*)([a-zA-Z]+)",line)
        match4 = re.match("(Save_Mesh_MSMS_Format\s*=\s*)([a-zA-Z]+)",line)
        # if(match):
        #     newline = match.group(1)+re.sub('\d+',str(grid_scale),match.group(2))+'\n'
        #     content[s] = newline
        #     s+=1
        #     continue
        # elif(match1):
        #     newline = match1.group(1)+re.sub('[a-zA-Z]+',"true",match1.group(2))+'\n'
        #     content[s] = newline
        #     s+=1
        #     continue
        if(match2):
            newline = match2.group(1)+re.sub('[a-zA-Z]+',"true",match2.group(2))+'\n'
            content[s] = newline
        elif(match3):
            newline = match3.group(1)+re.sub('[a-zA-Z]+',"true",match3.group(2))+'\n'
            content[s] = newline
        elif(match4):
            newline = match4.group(1)+re.sub('[a-zA-Z]+',"true",match4.group(2))+'\n'
            content[s] = newline
        s+=1
    NS_input.close()
    NS_input= open(confFile,'w')
    NS_input.writelines(content)
    NS_input.close()

    return

def new_probe(confFile,radius):
    s=0
    NS_input= open(confFile,'r')
    content = NS_input.readlines()
    for line in content:
        match = re.match("(Probe_Radius\s*=\s*)(\d*\.?\d+)",line)
        if match:
            newline = match.group(1)+re.sub('\d*\.?\d+',str(radius),match.group(2))+'\n'
            content[s] = newline
            break
        s+=1
    NS_input.close()
    NS_input= open(confFile,'w')
    NS_input.writelines(content)
    NS_input.close()
    return

############
###################  FUNTIONS USEFUL FOR CLUSTERING PROCESS ###################
def compare_ids(ids1,ids2):
    n = np.intersect1d(ids1,ids2,assume_unique=True).size
    return n


def area(a1,a2,a3): 
    """ Returns the area of a triangle
    """
  #Area = abs((xB*yA-xA*yB)+(xC*yB-xB*yC)+(xA*yC-xC*yA))/2
    x1 = a1[0]
    y1 = a1[1]
    x2 = a2[0]
    y2 = a2[1]
    x3 = a3[0]
    y3 = a3[1]
    return abs(0.5*(x1 * (y2 - y3) + x2 * (y3 - y1)  
                + x3 * (y1 - y2)))

def coplanar(n,o,p1,p2):
    """
    Returns True if p1 and p2 are at the same side of the plane of normal n and containing point o.

    """
    selfp = np.dot((p1-o),n)
    otherp = np.dot((p2-o),n)
    test_side = False
    if(np.sign(selfp*otherp)>0):
        test_side = True #same side
    return test_side;

############################
# ARRAY OPERATIONS 
###########
def pcross(v,w):
#With small arrays faster than numpy..
    z = np.empty(3)
    z[0] = ((v[1] * w[2]) - (v[2] * w[1]))
    z[1] = ((v[2] * w[0]) - (v[0] * w[2]))
    z[2] = ((v[0] * w[1]) - (v[1] * w[0]))
    return z


#####
def psum(v):
    # s=0
    # for e in v:
    #     s+=e
    return sum(v) #inbuilt function more efficient

# def pdot1D(v,w):
#     s=v[0]*w[0] + v[1]*w[1] + v[2]*w[2]
#     return s 

#############
#####

def get_plane(atoms,ind1,ind2 = None):
        """
            compute normals to the plane of the 2 triplets of atoms considered
            returns the normals and a reference atom

            IF one argument passed returns normal and all coordinates of trimming atoms 

            ----
            Parameters:
            2 list or np array, one for each triplet of atoms

        """
        #print("getting plane")
        if(ind2 is not None):

            a1_1 = atoms[ind1[0],0:3]
            a2_1 = atoms[ind1[1],0:3]
            a3_1 = atoms[ind1[2],0:3]

            a1_2 = atoms[ind2[0],0:3]
            a2_2 = atoms[ind2[1],0:3]
            a3_2 = atoms[ind2[2],0:3]

            #get normals 

            n1 = pcross((a2_1-a1_1),(a2_1-a3_1))#np.cross((a2_1-a1_1),(a2_1-a3_1))
            n2 = pcross((a2_2-a1_2),(a2_2-a3_2))#np.cross((a2_2-a1_2),(a2_2-a3_2))

            #normalize 
            n1 = n1/(np.sqrt(psum(n1*n1)))  #np.sum(n1**2)
            n2 = n2/(np.sqrt(psum(n2*n2)))  #np.sum(n2**2)
            
            return (n1,a1_1),(n2,a1_2)
        else:
            a1 = atoms[ind1[0],0:3]
            a2 = atoms[ind1[1],0:3]
            a3 = atoms[ind1[2],0:3]
            n =pcross((a2-a1),(a2-a3))#np.cross((a2-a1),(a2-a3))
            n = n/(np.sqrt(np.sum(n**2)))
            ref_atoms = np.stack([a1,a2,a3])
            return n,ref_atoms
    
#####################
################################### PDISTANCE AND INDEX RETRIEVAL ###############

def Pdist_C(X1,X2):
    """
    Pdist wrapper using shared C library for improved performance
    """
    m1,n1 = X1.shape
    m2,n2 = X2.shape
    if ((n1!=n2) and (n1!=3)):
        raise ValueError("Both imput arrays must have dimension equal to 3")
    # Convert to pointers for C
    X1 = np.ascontiguousarray(X1,dtype = ctypes.c_double)
    X2 = np.ascontiguousarray(X2,dtype = ctypes.c_double)
    pX1 = X1.ctypes.data_as(ctypes.POINTER(ctypes.c_void_p))
    pX2 = X2.ctypes.data_as(ctypes.POINTER(ctypes.c_void_p))
    ######

    if(np.array_equal(X1,X2)):
        flag = 1
        #scenario for comparison among same radius probes
        m = m1
        #fix correct dimension for output
        d = np.empty(m*(m-1)//2)
        #Again, broadcast to correct format for ctypes
        d = np.ascontiguousarray(d,dtype = ctypes.c_double)
        #pointer to d, the return variable
        pd = d.ctypes.data_as(ctypes.POINTER(ctypes.c_void_p))
        m = ctypes.c_int(m1)
        ####
        # Call to C func 
        pdist_C(pd,pX1,pX1,ctypes.c_int(1),m,m)
    else:
        flag = 0
        d = np.empty(m1*m2)
        d = np.ascontiguousarray(d,dtype = ctypes.c_double)
        pd = d.ctypes.data_as(ctypes.POINTER(ctypes.c_void_p))
        m1=ctypes.c_int(m1)
        m2=ctypes.c_int(m2)
        pdist_C(pd,pX1,pX2,ctypes.c_int(0),m1,m2)
    
    return d,flag;


def getIndex(flag,index,m):
    """
    Returns indexes of original observations corresponding to queried distance index
    Careful, if flag 0 m = size of second set of observations (m2 above)
    """
    if(flag==1):
        #pairwise distances among same set
        if (index>=m*(m-1)//2):
            exit("got too large index")
        b = 1 -2*m 
        i = int(np.floor((-b - np.sqrt(b**2 - 8*index))/2))
        j = int(index + i*(b + i + 2)/2 + 1)
        # _static_previous_m = m #not very nice since it depends on ordering in Pdist..
    elif(flag==0):
        #pairwise distances among different sets
        # if (index>=m*_static_previous_m):
        #     exit("got too large index")
        i = index//m 
        j = index%m 
    else:
        raise ValueError("flag must be provided with values 1 or 0")

    return (i,j);

##################
######################### READING AND PRINTING MOLECULES#######################
def readLigands(filename,proteinCoord=np.empty(0)):
    """
    Returns ligand coordinates from input pqr
    IF proteinCoord not empty, ligand coordinates are reduced to a subset within 5A from the protein --> To avoid noHit when most of ligand in solution
    """


    comment =['#', 'CRYST[0-9]?']
    remark = ['REMARK']
    termination = ['TER', 'END', '\n']
    skip = comment+remark+termination
    skip = '(?:% s)' % '|'.join(skip)
    # print("-- Loading PQR file --")
    # print(filename+".pqr")
    isPQR = False
    try:
        inFile = open(filename+".pqr",'r')
        isPQR = True
    except Exception:
        try:
            inFile = open(filename+".xyz",'r')
        except Exception:
            raise NameError("Cannot load ligand. File not found.")
    if isPQR:
        for line in inFile: 
            if(re.match(skip,line)): 
                pass 
            else:
                # line = line.split()
                linegNOChain=re.match("(ATOM|HETATM)\s*(\d+)\s*(\S+)\s+([A-Z]+)\s+(\-?\d+[A-Z]?)\s+(\-?\d*\.?\d+)\s*(\-?\d*\.?\d+)\s*(\-?\d*\.?\d+)\s+(\-?\d*\.?\d+)\s+(\d*\.?\d+)",line)
                linegChain = re.match("(ATOM|HETATM)\s*(\d+)\s*(\S+)\s+([A-Z]+)\s+([\w0-9]+)\s*(\-?\d+[A-Z]?)\s+(\-?\d*\.?\d+)\s*(\-?\d*\.?\d+)\s*(\-?\d*\.?\d+)\s+(\-?\d*\.?\d+)\s+(\d*\.?\d+)",line)

                break


        if(linegChain):
            # print("PQR contains CHAIN_ID")
            isChainID=1
            matchPattern = "(ATOM|HETATM)\s*(\d+)\s*(\S+)\s+([A-Z]+)\s+([\w0-9]+)\s*(\-?\d+[A-Z]?)\s+(\-?\d*\.?\d+)\s*(\-?\d*\.?\d+)\s*(\-?\d*\.?\d+)\s+(\-?\d*\.?\d+)\s+(\d*\.?\d+)"
        elif(linegNOChain):
            # print("PQR does NOT contain CHAIN_ID")
            isChainID =0
            matchPattern = "(ATOM|HETATM)\s*(\d+)\s*(\S+)\s+([A-Z]+)\s+(\-?\d+[A-Z]?)\s+(\-?\d*\.?\d+)\s*(\-?\d*\.?\d+)\s*(\-?\d*\.?\d+)\s+(\-?\d*\.?\d+)\s+(\d*\.?\d+)"
        else:
            raise NameError("Incorrect pqr file formatting")

        if(isChainID):
            resInd = 5
            chargeInd = 9
            rInd = 10
        else:
            resInd = 4
            chargeInd = 8
            rInd = 9
        nameInd = 3
        coordInd = resInd +1
        inFile.seek(0)
        ligand_coord = []
        for line in inFile: 
            if(re.match(skip,line)): 
                pass 
            else:
                # line = line.split()
                lineg = re.match(matchPattern,line).groups()
                content=list(map(float, lineg[coordInd:coordInd+3]))
                content.append(float(lineg[rInd]))
                ligand_coord.append(np.array(content)) #CONTAINS ALSO RADIUS
        # print("\n-- DONE --")
        ligand_coord = np.asarray(ligand_coord)
    else:
        ligand_coord = np.loadtxt(inFile)

    
    if(proteinCoord.size>0):
        #Only ligand atoms close to the protein surface are accounted
        d,flag = Pdist_C(ligand_coord[:,0:3],proteinCoord[:,0:3])
        index = np.where(d<=5)[0]
        lindex,_pindex=getIndex(flag,index,proteinCoord.shape[0])
        # print(lindex)
        # print(np.unique(lindex))
        # print(ligand_coord[np.unique(lindex)])
        ligand_coord = ligand_coord[np.unique(lindex)]
    else:
        pass

    # print(ligand_coord)
    
    return ligand_coord


def fetchRes(filename):
    """
    Builds a map between coordinates, residue name and atom in pqr structure file. Builds also the NS input file.
    Returns the list of radii of the protein atoms. 
    CAREFUL: OK only for PQR after conversion from PDB, where decent spacing among each field..
    PQR uses whitespaces as separator
    """

    # global resMap # List of dictionaryÃ¬ies mapping: atom label (line in file) <--> all infos 
    resMap = []
    content ={}
    # old_number = None


    comment =['#', 'CRYST[0-9]?']
    remark = ['REMARK']
    termination = ['TER', 'END', '\n']
    skip = comment+remark+termination
    skip = '(?:% s)' % '|'.join(skip)


    # print("-- Loading PQR file --")
    try:
        inFile = open(filename,'r')
    except Exception:
            raise NameError("Cannot load PQR file")
    for line in inFile: 
        if(re.match(skip,line)): 
            pass 
        else:
            #COMMENT: have to allow for negative res num, observed very rarely, but observed (ex 5olz..)
            linegNOChain=re.match("(ATOM)\s*(\d+)\s*(\S+)\s+([A-Z]+)\s+(\-?\d+[A-Z]?)\s+(\-?\d*\.?\d+)\s*(\-?\d*\.?\d+)\s*(\-?\d*\.?\d+)\s+(\-?\d*\.?\d+)\s+(\d*\.?\d+)",line)
            linegChain = re.match("(ATOM)\s*(\d+)\s*(\S+)\s+([A-Z]+)\s+([\w0-9]+)\s*(\-?\d+[A-Z]?)\s+(\-?\d*\.?\d+)\s*(\-?\d*\.?\d+)\s*(\-?\d*\.?\d+)\s+(\-?\d*\.?\d+)\s+(\d*\.?\d+)",line)
            break

    if(linegChain):
        isChainID=1                                                        #resID
        matchPattern = "(ATOM)\s*(\d+)\s*(\S+)\s+([A-Z]+)\s+([\w0-9]+)\s*(\-?\d+[A-Z]?)\s+(\-?\d*\.?\d+)\s*(\-?\d*\.?\d+)\s*(\-?\d*\.?\d+)\s+(\-?\d*\.?\d+)\s+(\d*\.?\d+)"
    elif(linegNOChain):
        isChainID =0                                        # resID
        matchPattern = "(ATOM)\s*(\d+)\s*(\S+)\s+([A-Z]+)\s+(\-?\d+[A-Z]?)\s+(\-?\d*\.?\d+)\s*(\-?\d*\.?\d+)\s*(\-?\d*\.?\d+)\s+(\-?\d*\.?\d+)\s+(\d*\.?\d+)"
    else:
        raise NameError("Incorrect pqr file formatting")

    if(isChainID):
        resInd = 5
        chargeInd = 9
        rInd = 10
    else:
        resInd = 4
        chargeInd = 8
        rInd = 9
    nameInd = 3
    atomInd = 2
    coordInd = resInd +1
    chainInd = 4
    
    inFile.seek(0)
    for line in inFile: 
        if(re.match(skip,line)): 
            pass 
        else:
            lineg = re.match(matchPattern,line).groups()
            if(isChainID):
                content = {'resName':lineg[nameInd],'resNum':lineg[resInd],'atomNumber':int(lineg[1]),'resAtom': lineg[atomInd],'resChain':lineg[chainInd],
                'charge':float(lineg[chargeInd]),'coord':list(map(float, lineg[coordInd:coordInd+3])),'radius':float(lineg[rInd])}
            else:
                content = {'resName':lineg[nameInd],'resNum':lineg[resInd],'atomNumber':int(lineg[1]),'resAtom': lineg[atomInd],
                'charge':float(lineg[chargeInd]),'coord':list(map(float, lineg[coordInd:coordInd+3])),'radius':float(lineg[rInd])}
            resMap.append(content)

    return resMap

def saveP(fileNumbering,savingDir,cluster,isPQR,subPockets = []):
    """
    Saves on file the pocket found.
    The numbering is given by the absolute number of saved entities
    """
    
    n = cluster.count

    coordinates=np.asarray(cluster.getCoordinates())

    name =savingDir+ "/clusterPocket"+str(fileNumbering)
    if(not isPQR):
        filename = name+".xyzr"
        np.savetxt(filename,(np.array(coordinates)),delimiter = '\t',header="Number of spheres:" + str(n))
    else:
        filename = name+".pqr"
        outFile = open(filename,'w')
        x = coordinates[:,0]
        y = coordinates[:,1]
        z = coordinates[:,2]
        r = coordinates[:,3]
        for i in range(n):
            # outFile.write("ATOM  %5d  %-3s %3s %c%4d    %8.3f%8.3f%8.3f%8.4f%8.4f\n" % (i,"C","NSR",'A',1,x[i],y[i],z[i],0.,r[i]) )
            outFile.write("{:<6s}{:>5d} {:<5s}{:>3s} {:1s}{:>5s}   {:>8.3f} {:>8.3f} {:>8.3f} {:>8.4f} {:>8.4f}\n".format('ATOM',i+1,'C','NSR','A','1',
                    x[i],y[i],z[i],0.,r[i]))
        outFile.close()
    if(subPockets):
        for k,(sub,_btlnk) in enumerate(subPockets):
            coordinates = np.asarray(sub.getCoordinates())
            n = sub.count
            if(not isPQR):
                filename = name+"_sub"+str(k+1)+".txt"
                np.savetxt(filename,(np.array(coordinates)),delimiter = '\t',header="Number of spheres:" + str(n))
            else:
                filename = name+"_sub"+str(k+1)+".pqr"
                outFile = open(filename,'w')
                x = coordinates[:,0]
                y = coordinates[:,1]
                z = coordinates[:,2]
                r = coordinates[:,3]
                for i in range(n):
                    # outFile.write("ATOM  %5d  %-3s %3s %c%4d    %8.3f%8.3f%8.3f%8.4f%8.4f\n" % (i,"C","NSR",'A',1,x[i],y[i],z[i],0.,r[i]) )
                    outFile.write("{:<6s}{:>5d} {:<5s}{:>3s} {:1s}{:>5s}   {:>8.3f} {:>8.3f} {:>8.3f} {:>8.4f} {:>8.4f}\n".format('ATOM',i+1,'C','NSR','A','1',
                    x[i],y[i],z[i],0.,r[i]))
                outFile.close()

    return;



def saveRes(fileNumbering,savingDir,cluster,resMap,atoms,bmouth = None, smouth = None, entrances=[],subPockets = []):
    """
     Saves on file the list of atoms relative to the input cluster
     and information on mouths: tangent atom coordinates, probe radius, normal, residues involved

     Returns instruction for drawing normal via VMD. The normal has as origin the probe projection on the mouth plane
    """

    rmin_bottlenecks = 2.0 # Bottlenecks shown to user
    
    content = set() #keep trace of already saved residue

    offset = 5

    resList=np.asarray(cluster.getAtomsIds())
    resList = np.unique(resList) #unique list of tangent atoms to the pocket (1D, the triplets get flattened)

    n = len(resList)

    name = savingDir+"/infoPocket"+str(fileNumbering)
    filename = name+".txt"
    outFile=open(filename,'w')

    nameP = savingDir+"/p"+str(fileNumbering)
    filename = nameP+"_atm.pqr"
    outFileP=open(filename,'w')
    
    writeList = []

    for r in resList:
        resid = resMap[r]['resNum']
        rname = resMap[r]['resName']
        try:
            rChain = resMap[r]['resChain']
        except KeyError:
            rChain = 'A'

        outFileP.write("{:<6s}{:>5d} {:<5s}{:>3s} {:1s}{:>5s}   {:>8.3f} {:>8.3f} {:>8.3f} {:>8.4f} {:>8.4f}\n".format('ATOM',r+1,resMap[r]['resAtom'],rname,rChain,resid,
        resMap[r]['coord'][0],resMap[r]['coord'][1],resMap[r]['coord'][2],resMap[r]['charge'],resMap[r]['radius']))

        if((resid,rname,rChain) in content):
            pass
        else:
        # writeList.append(ratom+"\t"+rname+"\t"+str(resid)+'\n')
            writeList.append(resid+"\t"+rname+' '+rChain+'\n')
            content.add((resid,rname,rChain))

    outFile.write("Number of residues %d\n" % len(content))
    outFile.writelines(writeList)

    #ENTRANCES:
    if(len(entrances)==0):
        pass
    else:
        outFile.write("\n\n ====== \n\n")
        n = len(entrances)
        outFile.write("#CLUSTERED ENTRANCES (rmin>2.5 and only when more than one). Total number %d:\n" %n)
        for e in entrances:
            ec = e[0] #entrance center
            radius = e[2]
            depth = e[1]
            size = e[4]
            residues = set([r[1] for r in e[5]]) #in case redundancy for multiple chains..
            normal = e[6]
            n_origin = ec
            n_end = ec + 10*normal
            outFile.write("\n Normal: ({:.2f},{:.2f},{:.2f}), entrance coordinate: ({:.2f},{:.2f},{:.2f}), effective radius:{:.2f},clustered exit spheres: {:d}\
            \nVMD--> draw cylinder {{{:.2f} {:.2f} {:.2f}}} {{{:.2f} {:.2f} {:.2f}}} radius 0.2 filled yes\nVMD--> draw cone {{{:.2f} {:.2f} {:.2f}}} {{{:.2f} {:.2f} {:.2f}}} radius {:.1f} resolution 100\n"
            .format(*normal,*ec,radius,size, *n_origin, *n_end,*n_origin, *n_end,radius))
            outFile.write("RESIDUES:")
            for r in residues:
                outFile.write('\n'+ r)

    #MOUTHS
    #bmout and smouth list [id_tangent atoms, radius of probe]
    if(smouth != None):
        #sort according to radius in descending order
        # smouth = sorted(smouth, key = lambda x: (x.r,x.count))[::-1] Now done externally

        n = len(smouth)
        outFile.write("\n\n ====== \n\n")
        outFile.write("#Pseudo-mouth list (threshold on aligned spheres and cluster size). Total number %d:\n" %n)
        c =0
        for s in smouth:
            IDmouthAtoms = s.t_atoms
            rad = s.r
            # if(rad>=rmin_entrance):
            coordinates = (atoms[IDmouthAtoms[0]],atoms[IDmouthAtoms[1]],atoms[IDmouthAtoms[2]])
            outFile.write("\n#Mouth {:d} of probe radius {:.2f} and atom coordinates ({:.2f},{:.2f},{:.2f}) r={:.1f},({:.2f},{:.2f},{:.2f}) r={:.1f},({:.2f},{:.2f},{:.2f}), r={:.1f})"
            .format(c,rad,*coordinates[0][0:3],coordinates[0][3],*coordinates[1][0:3],coordinates[1][3],*coordinates[2][0:3],coordinates[2][3]))
            
            refProbe = s.coord
            normal,atom_triplet = get_plane(atoms,IDmouthAtoms) # o is a reference atom belonging to the plane
            o = atom_triplet[0]
            normal = np.sign(np.dot((refProbe-o),normal))*normal #normal points towards the reference probe
            n_origin = refProbe - np.dot(normal,(refProbe-o))*normal
            n_end = refProbe + (np.dot(normal,(refProbe-o))+ offset)*normal

            outFile.write("\n Normal: ({:.2f},{:.2f},{:.2f}), reference probe coord: ({:.2f},{:.2f},{:.2f})\
            \n VMD--> draw cylinder {{{:.2f} {:.2f} {:.2f}}} {{{:.2f} {:.2f} {:.2f}}} radius 0.2 filled yes\n"
            .format(*normal,*refProbe, *n_origin, *n_end))
            content.clear()
            for r in IDmouthAtoms:
                rname = resMap[r]['resName']
                resid = resMap[r]['resNum']
                try:
                    rChain = resMap[r]['resChain']
                except KeyError:
                    rChain = 'A'
                if((resid,rname,rChain) in content):
                    continue
                else:
                    outFile.write('\n#'+ rname+"\t"+ str(resid))
                    content.add((resid,rname,rChain))
            c+=1
    if(bmouth != None):
        #sort according to radius in ascending order
        bmouth = sorted(bmouth, key = lambda x: x.r)
        n = len(bmouth)
        outFile.write("\n\n ====== \n\n")
        # outFile.write("\n\n#Bottleneck mouths list. Total number %d:\n" %n)
        outFile.write("\n\nBottlenecks with probe radius larger than %.1f:\n" %rmin_bottlenecks)
        c=0
        for b in bmouth:
            IDmouthAtoms = b.t_atoms
            rad = b.r
            if(rad>=rmin_bottlenecks):
                coordinates = (atoms[IDmouthAtoms[0]],atoms[IDmouthAtoms[1]],atoms[IDmouthAtoms[2]])
                outFile.write("\n#Mouth {:d} of probe radius {:.2f} and atom coordinates ({:.2f},{:.2f},{:.2f}) r={:.1f},({:.2f},{:.2f},{:.2f}) r={:.1f},({:.2f},{:.2f},{:.2f}), r={:.1f})"
                .format(c,rad,*coordinates[0][0:3],coordinates[0][3],*coordinates[1][0:3],coordinates[1][3],*coordinates[2][0:3],coordinates[2][3]))
                
                refProbe = b.coord
                normal,atom_triplet = get_plane(atoms,IDmouthAtoms) # o is a reference atom belonging to the plane
                o = atom_triplet[0]
                normal = np.sign(np.dot((refProbe-o),normal))*normal #normal points towards the reference probe
                n_origin = refProbe - np.dot(normal,(refProbe-o))*normal #projection of probe on the plane
                n_end = refProbe + (np.dot(normal,(refProbe-o))+ offset)*normal

                outFile.write("\n Normal: ({:.2f},{:.2f},{:.2f}), reference probe coord: ({:.2f},{:.2f},{:.2f})\
                \n VMD--> draw cylinder {{{:.2f} {:.2f} {:.2f}}} {{{:.2f} {:.2f} {:.2f}}} radius 0.2 filled yes\n"
                .format(*normal,*refProbe, *n_origin, *n_end))

                content.clear()
                for r in IDmouthAtoms:
                    rname = resMap[r]['resName']
                    resid = resMap[r]['resNum']
                    try:
                        rChain = resMap[r]['resChain']
                    except KeyError:
                        rChain = 'A'
                    if((resid,rname,rChain) in content):
                        continue
                    else:
                        outFile.write('\n#'+ rname +"\t"+ str(resid))
                        content.add((resid,rname,rChain))
                c+=1
    
    outFile.close()
    outFileP.close()


    #### SUBPOCKETS FILES...

    if(subPockets):
        #subPockets here is a list of cluster nodes
        for k, (sub,btlnks) in enumerate(subPockets):
            
            filename = savingDir+"/infoSub"+str(fileNumbering)+'_'+str(k+1)+".txt"
            outFile=open(filename,'w')
            
            filename = savingDir+"/sub"+str(fileNumbering)+'_'+str(k+1)+"_atm.pqr"
            outFileP=open(filename,'w')

            rad = sub.r
            IDmouthAtoms =  sub.t_atoms
            coordinates = (atoms[IDmouthAtoms[0]],atoms[IDmouthAtoms[1]],atoms[IDmouthAtoms[2]])
            
            refProbe = sub.coord
            normal,atom_triplet = get_plane(atoms,IDmouthAtoms) # o is a reference atom belonging to the plane
            o = atom_triplet[0]
            normal = np.sign(np.dot((refProbe-o),normal))*normal #normal points towards the reference probe

            resList = np.asarray(sub.getAtomsIds())
            resList = np.unique(resList) #unique list of tangent atoms to the pocket (1D, the triplets get flattened)

            n = len(resList)

            content.clear()
            writeList_s = []
            for r in resList:
                resid = resMap[r]['resNum']
                rname = resMap[r]['resName']
                try:
                    rChain = resMap[r]['resChain']
                except KeyError:
                    rChain = 'A'
                outFileP.write("ATOM  %5d%5s%4s%2s%4s    %8.3f%8.3f%8.3f%8.3f%8.3f\n" % (r+1,resMap[r]['resAtom'],resMap[r]['resName'],rChain,resMap[r]['resNum'],
                resMap[r]['coord'][0],resMap[r]['coord'][1],resMap[r]['coord'][2],resMap[r]['charge'],resMap[r]['radius']))
                if((resid,rname,rChain) in content):
                    pass
                else:
                    writeList_s.append(rname+"\t"+str(resid)+'\n')
                    # writeList.append(ratom+"\t"+rname+"\t"+str(resid)+'\n')
                    content.add((resid,rname,rChain))
            outFile.write("Number of residues %d\n" % len(content))
            outFile.writelines(writeList_s)
            
            #Writing mouth info..
            outFile.write("\n#Mouth probe radius {:.2f} and atom coordinates ({:.2f},{:.2f},{:.2f}) r={:.1f},({:.2f},{:.2f},{:.2f}) r={:.1f},({:.2f},{:.2f},{:.2f}), r={:.1f})"
            .format(rad,*coordinates[0][0:3],coordinates[0][3],*coordinates[1][0:3],coordinates[1][3],*coordinates[2][0:3],coordinates[2][3]))
            
            n_origin = refProbe - np.dot(normal,(refProbe-o))*normal
            n_end = refProbe + (np.dot(normal,(refProbe-o))+ offset)*normal 

            outFile.write("\n Normal: ({:.2f},{:.2f},{:.2f}), reference probe coord: ({:.2f},{:.2f},{:.2f})\
            \n VMD--> draw cylinder {{{:.2f} {:.2f} {:.2f}}} {{{:.2f} {:.2f} {:.2f}}} radius 0.2 filled yes\n"
            .format(*normal,*refProbe, *n_origin, *n_end))

            content.clear()
            for r in IDmouthAtoms:
                rname = resMap[r]['resName']
                resid = resMap[r]['resNum']
                try:
                    rChain = resMap[r]['resChain']
                except KeyError:
                    rChain = 'A'
                if((resid,rname,rChain) in content):
                    continue
                else:
                    outFile.write('\n#'+ rname+"\t"+str(resid))
                    content.add((resid,rname,rChain))
            if(btlnks):
                btlnks = sorted(btlnks, key = lambda x: x.r)
                n = len(btlnks)
                outFile.write("\n\n#Bottleneck mouths: %d\n" %n)
                c=0
                for b in btlnks:
                    IDmouthAtoms = b.t_atoms
                    rad = b.r
                    coordinates = (atoms[IDmouthAtoms[0]],atoms[IDmouthAtoms[1]],atoms[IDmouthAtoms[2]])
                    outFile.write("\n#Mouth {:d} of probe radius {:.2f} and atom coordinates ({:.2f},{:.2f},{:.2f}) r={:.1f},({:.2f},{:.2f},{:.2f}) r={:.1f},({:.2f},{:.2f},{:.2f}), r={:.1f})"
                    .format(c,rad,*coordinates[0][0:3],coordinates[0][3],*coordinates[1][0:3],coordinates[1][3],*coordinates[2][0:3],coordinates[2][3]))
                    
                    refProbe = b.coord
                    normal,atom_triplet = get_plane(atoms,IDmouthAtoms) # o is a reference atom belonging to the plane
                    o = atom_triplet[0]
                    normal = np.sign(np.dot((refProbe-o),normal))*normal #normal points towards the reference probe
                    n_origin = refProbe - np.dot(normal,(refProbe-o))*normal #projection of probe on the plane
                    n_end = refProbe + (np.dot(normal,(refProbe-o))+ offset)*normal

                    outFile.write("\n Normal: ({:.2f},{:.2f},{:.2f}), reference probe coord: ({:.2f},{:.2f},{:.2f})\
                    \n VMD--> draw cylinder {{{:.2f} {:.2f} {:.2f}}} {{{:.2f} {:.2f} {:.2f}}} radius 0.2 filled yes\n"
                    .format(*normal,*refProbe, *n_origin, *n_end))

                    c+=1
            outFile.close()
            outFileP.close()

    return
#########################################################
##############

def saveResSimple(fileNumbering,savingDir,cluster,resMap,nsub=None):
    
    '''
    Only produces the p_atm files
    '''


    resList=np.asarray(cluster.getAtomsIds())
    resList = np.unique(resList) #unique list of tangent atoms to the pocket (1D, the triplets get flattened)

    if(nsub is None):
        nameP = savingDir+"/p"+str(fileNumbering)
    else:
        nameP = savingDir+"/p"+str(fileNumbering)+"_sub"+str(nsub)
    filename = nameP+"_atm.pqr"
    outFileP=open(filename,'w')

    for r in resList:
        resid = resMap[r]['resNum']
        rname = resMap[r]['resName']
        try:
            rChain = resMap[r]['resChain']
        except KeyError:
            rChain = 'A'
        outFileP.write("{:<6s}{:>5d} {:<5s}{:>3s} {:1s}{:>5s}   {:>8.3f} {:>8.3f} {:>8.3f} {:>8.4f} {:>8.4f}\n".format('ATOM',r+1,resMap[r]['resAtom'],rname,rChain,resid,
        resMap[r]['coord'][0],resMap[r]['coord'][1],resMap[r]['coord'][2],resMap[r]['charge'],resMap[r]['radius']))


    outFileP.close()

    
    return


##################################### MORE (NOT CRUCIAL)#############
def drawSphere(xCenter, yCenter, zCenter, r):
    #draw sphere
    u, v = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j]
    x=np.cos(u)*np.sin(v)
    y=np.sin(u)*np.sin(v)
    z=np.cos(v)
    # shift and scale sphere
    x = r*x + xCenter
    y = r*y + yCenter
    z = r*z + zCenter

    return (x,y,z)
###################################
def cust_range(*args, rtol=1e-05, atol=1e-08, returnDelta=False,include=[True, False]):
    """
    https://stackoverflow.com/questions/50299172/python-range-or-numpy-arange-with-end-limit-include

    Combines numpy.arange and numpy.isclose to mimic
    open, half-open and closed intervals.
    Avoids also floating point rounding errors as with
    >>> numpy.arange(1, 1.3, 0.1)
    array([1. , 1.1, 1.2, 1.3])

    args: [start, ]stop, [step, ]
        as in numpy.arange
    rtol, atol: floats
        floating point tolerance as in numpy.isclose
    include: boolean list-like, length 2
        if start and end point are included
    """
    # process arguments
    if len(args) == 1:
        start = 0
        stop = args[0]
        step = 1
    elif len(args) == 2:
        start, stop = args
        step = 1
    else:
        assert len(args) == 3
        start, stop, step = tuple(args)

    # determine number of segments
    n = (stop-start)/step + 1

    # do rounding for n
    if np.isclose(n, np.round(n), rtol=rtol, atol=atol):
        n = np.round(n)

    # correct for start/end is exluded
    if not include[0]:
        n -= 1
        start += step
    if not include[1]:
        n -= 1
        stop -= step
    
    if(returnDelta):
        result = np.linspace(start, stop, num=int(n),retstep=True)
    else:
        result = np.linspace(start, stop, int(n))
    return result

def crange(*args, **kwargs):
    return cust_range(*args, **kwargs, include=[True, True])

def orange(*args, **kwargs):
    return cust_range(*args, **kwargs, include=[True, False])



###########################
# +++++++++++++++++++++++++ PRINTING STATS METHODS ++++++++++++++++++
def hitCounter(rank):
    """Function returning 1d array with each entry corresponding to ranking"""
    out = np.zeros(10)
    if(rank==0):
        out[0] = 1
    elif(rank==1):
        out[1] = 1
    elif(rank==2):
        out[2] = 1
    elif(rank==3):
        out[3] = 1
    elif(rank==4):
        out[4] = 1
    elif(rank==5):
        out[5] = 1
    elif(rank==6):
        out[6] = 1
    elif(rank==7):
        out[7] = 1
    elif(rank==8):
        out[8] = 1
    elif(rank==9):
        out[9] = 1
    return out


def save_rankingStats(model,alphas,betas,radii,top1,top3,top10,topAlsoSub,topOnlySub,SingleHit,OS,VS,volume,nPockets,nSubs,nAnalysed,names,date=''):  
    #nSubs averaged only over hitting pockets
    fp =  open("statTEST_"+names[model]+'.txt','w')
    
    fp.write("#"+date)
    fp.write("\n# Number of ligand-structure couples treated = %d"%nAnalysed)
    fp.write("\n#alpha\tbeta\trp_max\ttop1\ttop3\ttop10\tsubHit\tonlySub  singleHit\tLC\tPC\tAvVol\t\tnPockets nSubs\n")
    for i,a in enumerate(alphas):
        for j,b in enumerate(betas):
            for k,r in enumerate(radii):
                fp.write("\n%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t\t%.2f\t%.2f\t%.3f\t\t%.2f\t%.2f"%(a,b,r,
                np.round(top1[i,j,k,model],4)*100,np.round(top3[i,j,k,model],4)*100,np.round(top10[i,j,k,model],4)*100,
                np.round(topAlsoSub[i,j,k,model],4)*100,np.round(topOnlySub[i,j,k,model],4)*100,np.round(SingleHit[i,j,k,model],4)*100,
                np.round(OS[i,j,k,model],4)*100,np.round(VS[i,j,k,model],4)*100,np.round(volume[i,j,k,model],3),nPockets[i,j,k],nSubs[i,j,k,model]))
    fp.close()

def save_avHit(alphas,betas,radii,OS,VS,nhit,n_pockets,n_pockets_norm,n_subs,n_subs_norm,volume,volume_norm,n_spheresXP,n_spheres_normXP,n_spheres,n_spheres_norm,advancement,nAnalysed,date='',filename ="statANALYSIS.txt" ):
    fp =  open(filename,'w')
    fp.write("# ** AVERAGE HIT FILE **\n")
    fp.write("#"+date)
    fp.write("\n# %d / %d Structures processed (%.1f %%)" %(advancement[1],advancement[2],advancement[0]))
    fp.write("\n# Number of ligand-structure couples treated = %d"%nAnalysed)
    
    fp.write("\n#alpha\tbeta\trp_max\tLigand Coverage[%]\t Pocket Coverage[%]  HIT[%]  Npockets  Npockets_norm[%]  NsubP  NsubP_norm[%]  Av_vol  Av_volNorm[%]  Avsphs  Av_sphs_norm[%]  sphs  sphs_norm[%]")
    for i,a in enumerate(alphas):
        for j,b in enumerate(betas):
            for k,r in enumerate(radii):
                fp.write("\n %.2f\t%.2f\t%.2f\t%.2f\t\t%.2f\t\t%.2f\t\t%.2f\t%.2f\t%.2f\t%.2f\t\t%.2f\t%.2f\t\t%.2f \t%.2f  %.2f  %.2f"
                %(a,b,r,np.round(OS[i,j,k],4)*100,np.round(VS[i,j,k],4)*100,np.round(nhit[i,j,k],4)*100,
                np.round(n_pockets[i,j,k],2),np.round(n_pockets_norm[i,j,k],4)*100,
                np.round(n_subs[i,j,k],2),np.round(n_subs_norm[i,j,k],4)*100,np.round(volume[i,j,k],2),np.round(volume_norm[i,j,k],4)*100,
                np.round(n_spheresXP[i,j,k],2),np.round(n_spheres_normXP[i,j,k],4)*100,np.round(n_spheres[i,j,k],2),np.round(n_spheres_norm[i,j,k],4)*100)   )
    fp.close()

############ METHOD TO READ AND WRITE BINARY PICKLE FILES #################
import pickle
class writeBinary(object):
    def __init__(self,name):
        self.dbfile=open(name,'wb')
    def storeDict(self,db):
        #db = database, dictionary
        pickle.dump(db, self.dbfile) 
    def end(self):
        self.dbfile.close()

def loadDict(fileName):
    dictList = []
    with open(fileName, 'rb') as dbfile:
        while True:
            try:
                db = pickle.load(dbfile)
            except EOFError:
                break
            dictList.append(db)
    return dictList



def skeleton(pocket,prot,minsize=10,minsizeb = 10,weighted = False,sizeThMouth=True,plotSphere=False,extendedProperties=False): 
    """
    Argument must be a pocket (needs the field subpocket--which could be empty)
    """
    
    import matplotlib.pyplot as plt
    from mpl_toolkits import mplot3d
    from matplotlib.pyplot import cm
    from matplotlib.lines import Line2D


    fig=plt.figure(figsize = (8,6))
    ax = fig.add_subplot(111, projection='3d')
    plt.show(block=False)

    sref=200
    sref2=3000
    
    #f : figure container
    node=pocket['node']
    norm = node.count
    # sref2 = 2*norm#600
    # weak_aggregations = node.get_aggregations() #contains pyr and lateral aggregations indices
    filt_wa = list(filter(lambda x:(max(x[3],x[4])/min(x[3],x[4]) <= 5) and min(x[3],x[4]) >=minsize, pocket['aggregations']))
    # print([a[1:] for a in filt_wa])

    #nodes contain all nodes to extract from them 
    # bottlks_aggregations = pocket['btlnks'] 
    filt_b = list(filter(lambda x: x.count>=minsizeb, pocket['btlnks']))

    if('subpockets' in pocket):
        subpockets = pocket['subpockets'] #good to compare to this
    else:
        subpockets=[]

    largemouths = pocket['large_mouths'] # the starting spheres for entrance definition..
    allmouths = pocket['mouths']
    # largemouths = filter radius applied to allmouths (which are already filtered by size threshold, whilst large_mouths no)

    if sizeThMouth:
        mouths = largemouths
    else:
        mouths = allmouths
    

    # entrances = pocket['entrances']
    entrances=getEntrance(mouths,pwDist=True,extendedProperties=extendedProperties,structure=prot)


    for a in filt_wa:
        left = a[0].left
        right = a[0].right
        parent = a[0]
        cl = left.count/norm
        cr = right.count/norm
        cp = parent.count/norm
        xl= left.getCentroid(weighted)
        xr= right.getCentroid(weighted)
        # xp=parent.getCentroid()
        if(a[1][0]=="pyr"):
            xp = parent.coord
        else:
            #lat aggregation point to None reference coordinate
            xp=parent.getCentroid(weighted)
        ax.scatter(xl[0],xl[1],xl[2],marker="x",s=sref*cl,color='black')
        ax.scatter(xp[0],xp[1],xp[2],marker=".",color='black',s=sref*cp)
        ax.plot([xl[0],xp[0]],[xl[1],xp[1]],[xl[2],xp[2]],'--',color='black')
        ax.scatter(xr[0],xr[1],xr[2],marker="x",s=sref*cr,color='black')
        ax.plot([xr[0],xp[0]],[xr[1],xp[1]],[xr[2],xp[2]],'--',color='black')

    for b in filt_b:
        left = b.left
        right = b.right
        parent=b
        cl = left.count/norm
        cr = right.count/norm
        cp = parent.count/norm
        xl= left.getCentroid(weighted)
        xr= right.getCentroid(weighted)
        # xp=parent.getCentroid()
        xp = parent.coord
        ax.scatter(xl[0],xl[1],xl[2],marker="+",s=sref*cl,color='red')
        ax.scatter(xp[0],xp[1],xp[2],marker="s",s=sref*cp, color='red')
        ax.plot([xl[0],xp[0]],[xl[1],xp[1]],[xl[2],xp[2]],'--',color='red')
        ax.scatter(xr[0],xr[1],xr[2],marker="+",s=sref*cr,color='red')
        ax.plot([xr[0],xp[0]],[xr[1],xp[1]],[xr[2],xp[2]],'--',color='red')


    for sn,s in enumerate(subpockets):
        parent=s['node']
        print("sub %d size=%d"%(sn,parent.count))
        cp = parent.count/norm
        xp = parent.getCentroid(weighted)
        ax.scatter(xp[0],xp[1],xp[2],marker="*",s=sref2*cp, label="subpocket %d" %(sn+1))


    print("# entrances =", len(entrances))


    for en,e in enumerate(entrances):
        ec = e[0] #entrance center
        radius = e[2]
        depth = e[1]
        size = e[4]
        print("entrance %d , r= %.2f , d = %.2f, size= %d" %(en+1,radius,depth,size))
        # label = "entrance %d "%en +"Av depth= "+str(depth) + "Eff radius= "+str(radius)
        label = "entrance %d "%(en+1) +" Eff radius= "+str(radius)+"\n Entrance residues ="+str([r[1] for r in e[5]])
        if(plotSphere):
            #draw sphere 
            xs,ys,zs=drawSphere(ec[0], ec[1], ec[2], radius)
            ax.plot_wireframe(xs, ys, zs, linewidth = 0.2, color = 'gray')
        
        if(extendedProperties):
            ax.scatter(ec[0],ec[1],ec[2],marker="^",color="darkorange",linewidth=2, edgecolor='k', s = 200, label=label)
            enormal = e[6]
            ax.quiver(ec[0],ec[1],ec[2],enormal[0],enormal[1],enormal[2],lw =2,color="darkorange",length = 0.5*depth)
            # ax.plot_surface(xs, ys, zs,  rstride=4, cstride=4, color='g', linewidth=0, alpha=0.5)

    
    ax.legend()
    handles, labels = ax.get_legend_handles_labels()
    radii = np.unique(np.array([r[0].r for r in mouths ]))
    rmap = {r: i for i,r in enumerate (radii)}
    cL=cm.rainbow(np.linspace(0,1,radii.size))

    rdone=set()
    for m in mouths: #to use persitences I need related nodes..
        node=m[0]
        depth=m[1]
        r = node.r
        cp = node.count/norm
        center = node.getCentroid(weighted)
        refProbe = node.coord

        IDmouthAtoms =  node.t_atoms

        normal,atom_triplet = get_plane(prot.atoms,IDmouthAtoms) 
        o = atom_triplet[0] # o is a reference atom belonging to the plane
        normal = np.sign(np.dot((refProbe-o),normal))*normal #normal points towards the reference probe

        # end = normal
        # start = refProbe -(np.dot(normal,(refProbe-o))+depth)*normal #projection of probe on the plane
        # start =center
        start = refProbe # or the center
        # end= refProbe + np.dot(normal,(refProbe-o))*normal
        # arrow = end - refProbe
        arrow = normal
        # length = np.linalg.norm(refProbe -start) + depth
        length = depth/2
        # start = center 

        # ax.scatter(center[0],center[1],center[2],marker="D",s=sref2*cp, label=label)
        ax.scatter(refProbe[0],refProbe[1],refProbe[2],marker="o",color=cL[rmap[r]],linewidth=2, edgecolor='k',s=100*r/3.)
        if(r in rdone):
            pass
        else:
            rdone.add(r)
            handles.append(Line2D([0], [0], marker='o', color='w', label="pseudo-mouth r="+str(r),markerfacecolor=cL[rmap[r]], mec="k",markersize=10*r/3.))
        
        ax.quiver(start[0],start[1],start[2],arrow[0],arrow[1],arrow[2],lw =1,color="blue",length = 0.5*length)
    
    if(filt_b):
        handles.append(Line2D([0], [0], marker='s', color='w', label="bottleneck event",markerfacecolor="red", markersize=sref/25))
    ax.legend(handles=handles,loc='upper center',fancybox = True,bbox_to_anchor=(0.5,1.02))
    ax.set_yticklabels([])
    ax.set_xticklabels([])
    ax.set_zticklabels([])

    # ax.legend(loc='upper center',fancybox = True)
    return

def getEntrance(mouths,pwDist =False,extendedProperties=False,structure=None):
    # rmin = 2.5
    """
    Returns a list of tuples containing coordinate, average depth and rough mouth size estimation of the mouth

    Size of the mouth: average distance from weigthed center of mass + average radius

    OBS: This is single linkage. Could be interesting to do it based on baricenter, but more involving..


    Structure is the clustering.protein container
    """
    #1.  Indentification of clustered exit spheres and gathering in a container 
    # mouths = list(filter(lambda x : x[0].r > rmin , mouths))
    n = len(mouths)
    # print("Original number of elements",n)
    X = np.empty((0,4))
    aggregationList={}
    #each one is a singleton

    #MOUTHS CONTAIN:
    #aggregationList = list of (clusterNode,depth)
    

    for s,m in enumerate(mouths):
        #print(m[0].r,m[1])
        X = np.vstack((X,np.append(m[0].coord,m[0].r))) #x,y,z,r coordinate array
        aggregationList[s]={m} #each sphere initially a singleton 

    d,condition = pdist_weight(X,pwDist)
    index = np.where(d<condition)[0]
    
    for k in index:
        i,j = getIndex(1,k,n)
        # print(i,j,mouths[i][0].coord,mouths[j][0].coord)
        m_i = mouths[i]
        m_j = mouths[j]
        #avoiding for loop for possible problems in deletion of element while looping
        # do all an indices rather than nodes?
        if(i in aggregationList):
            # print("%d in aggr list" %i)
            if(m_j in aggregationList[i]):
                # print("already in same cluster")
                continue 
            else:
                # indexMap[j]=i
                # aggregationList[i]= aggregationList[i].union(aggregationList[indexMap[j]])
                aggregationList[i].add(m_j)
                # print("deleting %d from list" %j)
                try:
                    del aggregationList[j]
                except:
                    # print("the element is already contained in another cluster!")
                    for index,a in aggregationList.items():
                        if(m_j in a):
                            aggregationList[index]=aggregationList[index].union(aggregationList[i])
                            del aggregationList[i]
                            break

        elif(j in aggregationList):
            # print("%d in aggr list" %j)
            if(m_i in aggregationList[j]):
                # print("already in same cluster")
                continue
            else:
                aggregationList[j].add(m_i)
                # indexMap[i]=j
                # aggregationList[j]= aggregationList[j].union(aggregationList[indexMap[i]])
                # print("deleting %d from list" %i)
                try:
                    del aggregationList[i]
                except:
                    # print("the element is already contained in another cluster!")
                    for index,a in aggregationList.items():
                        if(m_i in a):
                            aggregationList[index]=aggregationList[index].union(aggregationList[j])
                            del aggregationList[j]
                            break
        else:
            # print("Index not found. Checking if in same cluster")
            merging = False
            for index,a in aggregationList.items():
                if m_i in a:
                    if m_j in a:
                        # print("Ok in same cluster")
                        break
                    else:
                        mindex_i = index
                if m_j in a:
                    if m_i in a:
                        # print("Ok in same cluster")
                        break
                    else:
                        mindex_j = index
                        merging = True
            if merging:
                # print("Merging: ", mindex_i, mindex_j)
                aggregationList[mindex_i]=aggregationList[mindex_i].union(aggregationList[mindex_j])
                del aggregationList[mindex_j]

    # print("--")
    
    #2. Population of output list and computation of entrance properties
    #sort aggregation list by number of members

    # HERE GATHERING PROPERTIES OF ENTRANCES..
    if extendedProperties:
        if(structure is None):
            print('need protein residues passed to return residues information of entrances')
            extendedProperties=False
        else:
            resMap = structure.resMap
            atoms = structure.atoms
    entrances=[]
    for ids,a in sorted(aggregationList.items(),key = lambda x: len(x[1]),reverse=True):
        size = len(a)
        # print(ids,size,[(i[0].coord,i[0].r) for i in a])
        coord = np.array([i[0].coord for i in a])
        radii = np.array([i[0].r for i in a])
        depths = [i[1] for i in a]
        # print(coord.shape)
        # print(radii.shape)
        r_av = sum(radii)/size
        cm = sum(radii[:,None]*coord)/sum(radii)
        av_dist = sum([Eucl_dist(cm,c) for c in coord])/size
        r_eff = r_av + av_dist #simple estimate 
        d_av = sum(depths)/size
        r_eff = np.round(r_eff,2) #effective radius of the entrance (Entrance size is twice it..)
        r_av  = np.round(r_av,2)
        cm = np.round(cm,4)
        d_av=np.round(d_av,1)
        if not extendedProperties:
            entrances.append((cm,d_av,r_eff,r_av,size))
        else:
            resInd = np.array([i[0].t_atoms for i in a])
            # print(resInd)
            resInd = np.unique(resInd)
            # print(resInd)
            # print()
            resEntrance = []
            for i in resInd:
                resid = resMap[i]['resNum']
                rname = resMap[i]['resName']
                try:
                    rChain = resMap[i]['resChain']
                except KeyError:
                    rChain = 'A'
                resEntrance.append((resid,rname,rChain))
            resEntrance = set(resEntrance)
            #unique normal x entrance
            normals=[]
            for s in a:
                # radius = s[0].r
                normal,atom_triplet = get_plane(atoms,s[0].t_atoms) 
                o = atom_triplet[0] # o is a reference atom belonging to the plane
                refProbe = s[0].coord
                normal = np.sign(np.dot((refProbe-o),normal))*normal # orient it towards refProbe
                normals.append(normal)
                
            # print(normals)
            av_normal=np.average(normals,weights = radii, axis=0)
            entrances.append((cm,d_av,r_eff,r_av,size,resEntrance,av_normal))

    return entrances




def Eucl_dist(a,b):
    d = np.sqrt(sum((a-b)**2))
    return d

def pdist_weight(w_coord,powerDist=False):
    n = w_coord.shape[0]
    coord =w_coord [:,0:3]
    r = w_coord [:,3]
    d =np.empty(n*(n-1)//2)
    condition = np.empty(n*(n-1)//2)
    # print("n exit spheres=",n)
    k=0
    for i in range(n-1):
        for j in range(i+1,n):
            d[k] = Eucl_dist(coord[i],coord[j])#np.sqrt(np.sum((coord[i]- coord[j])**2))
            if(powerDist):
                condition [k] = np.sqrt(r[i]**2+r[j]**2)
            else:
                condition [k] = r[i]+r[j]
            k+=1
    return d,condition


def getRanking_volume(geomList):
    "use only volume"
    v_list = np.array([g[1] for g in geomList])
    
    
    rank = np.argsort(v_list)[::-1]
    score = 1-v_list/np.amax(v_list) #0 better 1 worst. Anyhow this is not comparable to isolation forest anomaly scores..

    # DEBUG
    # print(np.sort(v_list)[::-1])
    # print(np.sort(score))
    # print(rank)
    ########
    rankSub = rank
    #same ranking is used for subpockets 
    return rank,rankSub,np.sort(score),np.sort(score)


def extractOFF(inputFileName,skip = 2):
    '''
    Extract vertices coordinates from a OFF file..
    '''
    file = open(inputFileName,'r')
    if 'OFF' != file.readline().strip():
        raise('Not a valid OFF header')
    for i in range(skip):
        _skipped_line=file.readline()
        # print(skipped_line)
    n_verts, n_faces, n_dontknow = tuple([int(s) for s in file.readline().strip().split(' ')])
    verts = [[float(s) for s in file.readline().strip().split(' ')] for i_vert in range(n_verts)]
    faces = [[int(s) for s in file.readline().strip().split(' ')][1:] for i_face in range(n_faces)]
    return verts, faces

def centerOfMass(verts):
    '''
    Returns the center of mass from a list of vertices of the triangulation
    '''
    verts = np.array(verts)
    CM = np.mean(verts,axis=0)

    return CM



def matchMeasure(ligand_coord_file,pocketAtoms_file,distanceTh=5.):
    '''Utility function to asses pocket performance.
    Supports ligands in xyz file and assumes PQR or PDB:q::q contains CHAIN'''
    comment =['#', 'CRYST[0-9]?']
    remark = ['REMARK']
    termination = ['HEADER','TER', 'END', '\n']
    skip = comment+remark+termination
    skip = '(?:% s)' % '|'.join(skip)

    # Assuming we always have chain
    resInd = 5
    coordInd = resInd +1



    ligFile=open(ligand_coord_file,'r')
    ligand_coord = np.loadtxt(ligFile)

    pFile=open(pocketAtoms_file,'r')
    pocketsCoord=[]
    for line in pFile: 
        if(re.match(skip,line)): 
            continue 
        
        line = line.split()
        content=list(map(float, line[coordInd:coordInd+3]))
        
        pocketsCoord.append(content)
    pocketsCoord = np.array(pocketsCoord)


    print("Ligand coords:",ligand_coord)
    print("\nPockets coord:",pocketsCoord)

    n_ligand = ligand_coord.shape[0]
    n_pocket = pocketsCoord.shape[0]

        # print("Number of atoms ligand=%d\n Number of atoms pocket=%d" %(n_ligand,n_pocket))#CHECK

    d = np.empty(n_ligand*n_pocket)

    d,_flag = Pdist_C(ligand_coord,pocketsCoord)

    rowmap = np.ones(n_pocket,bool)*False
    n_inLig=0
    for i in range(n_ligand):
        rw = d[i*n_pocket:(i+1)*n_pocket]<=distanceTh #= row: distance relations between atom ligand and all pocket atoms"
        rowmap = np.logical_or(rw,rowmap)
        n_inLig+=np.any(rw) #at least one per row = one hit
    n_inP= np.sum(rowmap)#can be seen as a mask where a true entry is a hit, a pocket atom within the distance threshold

    matchScore = n_inLig/n_ligand
    coverageScore = n_inP/n_pocket

    print("Overlap Score = ",matchScore)
    print("Volume Score = ",coverageScore)

    return 





